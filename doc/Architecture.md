# The Simulation Engine Architecture

The simulation engine consists of a few basic items, constructed in such a way
that they allow rich, dynamic behaviors.

1. **[Pragma](Pragma.md):** the building block for the engine.  They contain
 [Attributes](Attribute.md) and [Links](Link.md) in a single wrapper.  Each
 Pragma has a globally unique identifier.
2. **[Attribute](Attribute.md):** a value on a Pragma which must be of a
 specific [Value Type](Value-Type.md).  It may either be a variable or a
 function.  The identifiers for Attributes are global, so that all attributes
 with the same ID must have the same type.  This also implies that all Pragma
 have every Attribute value, with a default value of null.  When an Attribute
 value changes, it signals a change event.
3. **[Link](Link.md):** an identifier on a Pragma that maps to a Pragma global
 ID.  Attributes can reference the value in a linked-to Pragma value, and the
 mapping allows for easy dynamic changes to the links.  Links can also have
 their own associated Attributes.
4. **[Function](Function.md):** a transformation, that takes 0 or more
 read-only Attribute values as arguments, and returns a single value.
 Functions are bound to Attributes, and the return value can be used as input
 to other functions.
5. **[Action](Action.md):** describe an ordered set of changes to the
 simulation.  They execute when the bound-to [[Attribute]] changes value.
 Actions run inside a [[Context Space]] to isolate their state changes from
 each other.
6. **[Context Space](Context-Space.md):** a set of "weak copies" of Pragmas
 which are subject to change by one or more Actions.  When the Actions complete
 their execution in the cycle, the Context Space commits its changes back to the
 master copy.

Additionally, there are
[some items that are still in flux](Architecture-Outstanding-Questions.md).


## Comparison With Other Computation Systems

[Functions](Function.md) closely resemble
[futures](http://en.wikipedia.org/wiki/Future_%28programming%29) that are never
lazy loaded (due to the immediacy needs for signaling).  The hard values are
"concurrent logic variables" that support
[unifications](http://en.wikipedia.org/wiki/Unification_%28computing%29).

This system has many similarities to an
[Actor model](http://en.wikipedia.org/wiki/Actor_model).  However,
[Pragmas](Pragma.md) break the Actor requirements by not being local - the
[Actions](Action.md) that affect Pragma do not run in a shared space.

The system is discrete because it executes a single pass of processing signals
as a batch as a cycle. This allows for easier debugging of the operation of the
system, and a higher level of determinism (but does not imply a fully
deterministic system). A continuous system, on the other hand, processes the
signals as they occur, without an obvious subdivision of time - that is, the
system can process new signals between discrete time increments.

The system is reactive because the system only allows communication between its
parts through signals generated by changes to the system state.
