<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link href="style.css" media="all" rel="stylesheet" type="text/css" />

    <title>Template - Discrete Reactive Simulation Architecture</title>
</head>
<body>
<ol id="stoc">
    <li><a href="index.html">Overview</a></li>
    <li><a href="action.html">Action</a></li>
    <li><a href="attribute.html">Attribute</a></li>
    <li><a href="engine_algorithm.html">Engine Algorithm</a></li>
    <li><a href="function.html">Function</a></li>
    <li><a href="pragma.html">Pragma</a></li>
    <li class="selected"><a href="template.html">Template</a></li>
    <li><a href="value_types.html">Value Types</a></li>
</ol>
<h1>Discrete Reactive Simulation Architecture</h1>



<h2>Templates</h2>
<p>
    A Template is a <a href="pragma.html">Pragma</a> which the engine uses
    to populate other <a href="pragma.html">Pragma</a> instances.  Any
    <a href="pragma.html">Pragma</a> can be used as a Template (which is
    how <a href="pragma.html#clone">strong copies</a> are made).
</p>
<p>
    Most Templates, however, possess special wiring to allow for signaling
    Actions on the destination <a href="pragma.html">Pragma</a> after
    construction.  Additionally, they have special
    <a href="attribute.html">Attributes</a> that define the <em>priority</em>
    for the value - whether to override the value or use the existing value.
</p>

<h3>TODO Vague Concept</h3>
<p>
    This is all pretty vague right now, or relies upon conventions,
    which should be a red flag that
    this needs deeper investigation.  It might just lead to a new construct
    explicitly for Templates.  However, there's also a desire to use this
    simple idea to allow for making hard copies of Pragmas: the kernel of the
    concept has a simplicity that I like, but there are small use cases that
    need to be considered.
</p>
<p>
    These are the different use cases I've come up with, in relative
    priority order:
</p>
<ol>
    <li>
        Populate a new Pragma with some data to allow easy "cookie cutter"
        copies of similar objects.  This is modeling the "class" concept.
    </li>
    <li>
        Allow updating existing Pragma objects with new functionality from a
        new plugin added into the simulation.  The plugin would have matchers
        to determine which Pragma to update with what values, and it needs to
        know whether to override the existing value or keep the existing value
        or use some combination of them.
    </li>
    <li>
        Add new behavior to an existing Pragma based on a state change.
        For example, a wooden doll comes to live with a magic spell, causing it
        to now become an active member of the simulation.  The Pragma itself
        didn't change, and there's no need to go through the hassle of
        reconnecting all the links.
    </li>
    <li>
        Create a copy of an existing Pragma, so that concepts like,
        "split a pile of 37,656 leaves into 2 piles" can be trivial to solve.
    </li>
</ol>
<p>
    These are the different solution ideas I have:
</p>
<ul>
    <li>
        A "priority" on both attributes - the higher priority
        wins.  However, this doesn't tell the system what happens to the
        priority after construction, or what to even set it to in the
        copy if it's a new object.
    </li>
    <li>
        Two sub-pragmas, one with defaults, and one with overrides.
        This doesn't give a nuanced solution, because there are
        situations where the current value determines what should
        happen.  This means having special "convention" keywords for the
        link names.
    </li>
    <li>
        The invocation to perform the copy takes an optional Pragma
        that defines the list of attributes to copy by value (creating hard
        links).  This allows for a two-pass
        copy to perform the necessary actions; the first is copying a
        "filter" pragma that has a link to the original object, and all the
        additional function linking via values, and the second is copying
        the filter pragma onto the destination.  The original will need to
        be a weak "predictive" copy, to make sure it retains the original
        values.  For a full copy to take place would require multiple
        runs through the computation chain within a single cycle.
    </li>
</ul>


<h3>Lifecycle</h3>
<p>
    Because Templates use the existing <a href="pragma.html">Pragma</a>
    structure, they require <em>conventions</em> to detail how the engine
    manipulates the Template and destination <a href="pragma.html">Pragma</a>.
</p>




<h3><a name="mixin">Templates as Classes and Mixins</a></h3>
<p>
    A Template can be used to have similar functionality to a Class or Mixin
    concept.  The Template provides data fields (default Attributes) and
    methods (Actions and Functions) for the new instance.
</p>
<p>
    The <em>convention</em> to using Templates which require a programmatic
    behavior uses an Attribute ("AddedTemplates") - a set of Strings - which
    contains all the global IDs of the Templates which copied themselves into
    the <a href="pragma.html">Pragma</a>, and they add a bound Action to that
    Attribute that performs the initialization when it changes value, which will
    always be triggered after copying in a Template.  The initializer should
    remove itself at the end of the action to ensure another Template copy
    doesn't trigger it again.
</p>


<h3><a name="patch">Plugin vs. Patching</a></h3>

<p>
    Templates also allow for installing extensions and patches into an existing
    simulation.  A <em>Plugin</em> package refers to a bundle that contains
    new behaviors or additional interactions to the simulation.  A
    <em>Patch</em> refers to updates to existing interactions and behaviors
    to remove issues or enhance existing functionality.
</p>


</body>
</html>
