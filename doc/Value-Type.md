The architecture supports a finite list of strong types for its values, and sets
of these values. Because of this definition, the types do not allow for
sets-of-sets.

* **String** - an ordered collection of character data.
* **Numeric** - a deterministic real number.
* **Fuzzy** - a number in the range [0, 1] with specific multi-valence set
  operations. Systems should use these to represent values restricted to a
  range, or booleans.
* **Pragma Link ID** - a reference to a Link ID for a [Pragma](Pragma.md). The
  reference does not itself reference a Pragma, nor does it reflect the
  linked-to Pragma on the currently bound Pragma, but instead must be bound to
  an owning Pragma to find the Pragma by its Link ID.
* **Attribute ID** - a reference to a global attribute identifier, without any
  binding to a specific Pragma or its links.
* **Attribute Link - a combination of a Pragma Link and an Attribute ID.
* **Pragma Handle** - a [reference](Link.md) to a specific [Pragma](Pragma.md);
  the result of a Pragma Link bound to an owning Pragma.
* **Attribute Handle** - a [reference](Link.md) to an
  [Attribute Value](Attribute.md) on a specific [Pragma](Pragma.md); the result
  of an Attribute Link bound to an owning Pragma.


## Sets

As mentioned above, the engine supports sets of the basic value types, but not
sets-of-sets. Note that these are "sets", meaning that they cannot contain
multiple instances of the same referent value. This means that a set cannot
contain to values from the same attribute, but it can hold, say, two different
attribute values that are both set to 2.

Also, sets have the potential to be lazy-loaded in order to facilitate highly
parallel operations. Because of this, the access to the values in a set are very
restricted.


## Data Type Transformation

The system does not allow for implicit transformation from one type to another;
such transformations must occur through a built-in [Function](Function.md).

This also means that there MUST NOT be a construction of a reference to an ID by
concatenating strings or numbers. These should be handled carefully, and
constructs containing lists of Pragma should actually use a list of Links,
rather than building those Links.


## Null Values

All value types allow for a null value, which indicates an absence of a value.
All base operations on value types require null safety.

Each type has a specific meaning for null values, as interpreted by the
low-level operations, but additional operations allow for inspecting whether the
value is null or not.

* **Set** - an empty set
* **String** - an empty string
* **Numeric** - 0
* **Fuzzy** - 0 (which allows Boolean representations reflect allow unassigned
  values as false)
* **Pragma Link** - a null [Pragma](Pragma.md), which means a
  [Pragma](Pragma.md) with only Null values for Attributes and Links
* **Unassigned Link** - also represents a null Pragma.
* **Attribute Link** - has the same semantics as a null Pragma Link, but
  references the [Attribute](Attribute.md) of that null [Pragma](Pragma.md).

Note that a Set will never contain null values. It can contain a link to an
unassigned Pragma, but not null links.


## Links and Handles

_Main page: [Link](Link.md)_

[Pragma](Pragma.md) contain a list of _Link Mappings_ that reference globally
unique Pragma IDs from a generic _Link ID_. This allows for a common ID to
reference a linked [Pragma](Pragma.md) (such as "location").

A _Link Value Type_ is simply the generic Link ID.  Because the ID is not bound
to a specific Pragma, it does not reference anything. Binding a Pragma Link
Value to a Pragma creates a Handle to the Pragma referenced by the Link with
that generic ID.

Likewise, an Attribute Link is a generic Link ID into that list of references,
along with an Attribute ID, and binding an Attribute Link to a Pragma results in
a Handle to the [Attribute](Attribute.md) with that ID on the
[Pragma](Pragma.md) in the Links with that generic ID.

An Attribute ID can also be bound to a [Pragma](Pragma.md) to create an
Attribute Handle.

The system makes a strong distinction between a [Pragma](Pragma.md) and its
Handle in order to enforce the limited scope a [Function](Function.md) has on
its input.  The [Function](Function.md) may output a Pragma Handle or Attribute
Handle from the binding, which allows the signals generated by changes on the
corresponding [Attribute](Attribute.md) or [Pragma](Pragma.md) to trigger
[Actions](Action.md).


## Change Signals

The simulation engine concerns itself primarily with the management of
relationships between [Functions](Function.md) and Values, and the creation of
signals based on changes to those [Functions](Function.md) and Values.

The engine triggers the execution of an [Action](Action.md) when the bound-to
[Function](Function.md) or Value changes. The meaning of "change" depends upon
the value type.

For the simpler types - **String**, **Numeric**, and **Fuzzy** - the engine
considers the value changed when the previous value differs from the
just-committed value.

The Link types are just as simple in their meaning of change. Pragma Link
values, Attribute ID values, and Attribute Link values signal changes when the
value of the ID to which they reference changes; for the Attribute Link, this
means either the Pragma ID or the Attribute ID.

A Pragma Handle signals a change when the handle changes to a different
[Pragma](Pragma.md). So, if the Pragma referenced by the corresponding Link
changes, then the Pragma Handle changes, resulting in the change signal. A
removal of a reference to a Pragma in the links results in a null
[Pragma](Pragma.md) referenced by the Handle. It also can potentially change
when the Link ID changes value.

Likewise, an Attribute Handle signals a change just like a Pragma Handle, when
the corresponding linked-to Pragma changes, or when the Attribute ID in the
corresponding Attribute Link changes to reference a different Attribute ID.

