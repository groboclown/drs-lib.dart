<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link href="style.css" media="all" rel="stylesheet" type="text/css" />

    <title>Pragma - Discrete Reactive Simulation Architecture</title>
</head>
<body>
<ol id="stoc">
    <li><a href="index.html">Overview</a></li>
    <li><a href="action.html">Action</a></li>
    <li><a href="attribute.html">Attribute</a></li>
    <li><a href="engine_algorithm.html">Engine Algorithm</a></li>
    <li><a href="function.html">Function</a></li>
    <li class="selected"><a href="pragma.html">Pragma</a></li>
    <li><a href="value_types.html">Value Types</a></li>
</ol>
<h1>Discrete Reactive Simulation Architecture</h1>


<h2>Pragma</h2>

<p>
    A Pragma contains independent data associated with
    <a href="attribute.html">Attributes</a>, and
    <a href="value_types.html#link">Links</a> to Pragma, and itself has a
    globally unique identifier.  It also has Actions bound to change signals
    on Attributes of the Pragma.
</p>
<p>
    The system acts as though Pragma have all
    <a href="attribute.html">Attributes</a> and
    <a href="value_types.html#link">Links</a> defined for them, defaulting to
    <a href="value_types.html#null">null values</a>.  This allows references to
    not-existing or undefined values to work if a future
    <a href="action.html">Action</a> defines them.
</p>



<h3><a name="link">Links</a></h3>
<p>
    A Pragma contains a list of generic IDs bound to Pragma global IDs, in
    the form of a mapping.  By having a generic Link ID and a Pragma, a
    Function or Action may retrieve the referenced Pragma.
</p>
<p>
    By having this generic ID mapping, a system can construct a name, such
    as "inside", that can be used for all Pragma to define a concept.
</p>
<p>
    Links in a Pragma may themselves have Attributes.  These are actually stored
    in the owning Pragma as an Attribute, and as such are globally unique IDs
    binding a generic Link ID to the link-specific Attribute ID.
</p>



<h3><a name="commit">Commit Memory Model</a></h3>
<p>
    Due to the simulation engine running in discrete cycles, as well as changes
    to values performed only by Actions, the memory model works by creating
    a "Weak Copy" of Pragma on which an Action performs changes, and resolves
    the changes after the Actions complete their work by committing back to
    the original Pragma.
</p>
<p>
    Weak Copies of Pragma created for Actions schedule themselves to commit
    changes to their <a href="attribute.html">Attributes</a> back to the
    original Pragma on a
    per-<a href="attribute.html">Attribute</a> basis, allowing for heavy
    parallelization.  The commit uses the Join Commit function on the Attribute
    to determine how to resolve differences if multiple Actions update the
    same attribute value.
</p>
<p>
    Because an Action can act upon more than one object, all these changes
    to Pragma made by the action are stored in a context.  A context is a
    weak copy of the entire parent context,
    so that it maintains a list of only the values that have changed within
    the child context.
</p>
<p>
    Signals to Actions bound to Pragma in a context would act upon
    that weak copy of the Pragma.  Pragma Links can reference any Pragma in
    context, so that "what-if" values can be pulled in.  Pragma Links can only
    reference child contexts, so that a strict tree
    structure is maintained.  This, a context is its own little simulation
    within a simulation.
</p>
<p>
    With this predictive analysis design, we could potentially shape the
    commit model to use it.  When an Action runs, it runs in its own
    child context.  New Pragma are created in the child context, and alterations
    are kept inside the child.  When the Action finishes, the context is
    committed back to the parent.  This technique
    allows for the highly parallel execution of Actions.
</p>
<p>
    In the future, the engine might also allow for special handling for
    serialized actions, in which case a task scheduling scheme can be
    constructed as well.  The string
    of Actions creates levels of contexts in which parallel Actions create
    their children, and those are committed into the parallel context before
    the next serial action happens.
</p>
<p>
    Commits from a context back to the parent occur on an Attribute-by-Attribute
    basis.  Each Attribute has a "commit join" function that accepts 3
    arguments: attribute handle, the original
    value, and a lazy list containing the child context values as they are
    computed.  However, there's a hard problem around
    handling conflicts in removed / added / etc Links.  Newly created Pragma are
    handled gracefully because they are assigned a globally unique ID.  Deleted
    Pragma can cause a conflict, though.  Unfortunately, a delete is hard to
    manage because sets cannot contain null values (see
    <a href="index.html">the front page</a> for current issues).
</p>



<h3><a name="creation">Pragma Creation</a></h3>
<p>
    An <a href="action.html">Action</a> can create a new Pragma that contains
    only default values for Links and Attributes.  The simulation engine
    creates this Pragma with a globally unique ID, based on a suggested name
    from the calling Action.
</p>
<p>
    Due to the <a href="#commit">Commit memory model</a>, the engine can
    create and make the new Pragma available immediately, because no
    bound Attributes or Links to it exist.  Likewise, within the context of
    the calling Action, additional Links and Attributes can be added to it
    immediately.
</p>



<h3><a name="clone">Cloning</a></h3>
<p>
    Creates a full new copy of an existing Pragma.  This includes correct
    duplication of the back links and a unique ID.  This allows for cloning
    existing objects for permanent storage in the system.
</p>
<p>
    The "clone" operation is only allowed inside an Action.  The operation
    takes several arguments to alter the behavior of the clone:
</p>
<ul>
    <li>
        <strong>as defaults</strong> - a flag that, if set, will not change
        a value in the destination if it is already non-null.
    </li>
    <li>
        <strong>filter</strong> - a set of Attribute IDs and Link IDs,
        which limits which attributes and links are copied.
    </li>
</ul>
<p>
    Because of the way the <a href="#commit">commit</a> works for memory
    integrity, a Strong Copy of
    a Pragma has no commit phase into the system.  The system adds it directly
    into the system, giving it a globally unique ID (possibly with a suggestion
    from the user).
</p>
<p>
    See <a href="index.html">the front page</a> for issues around notifications
    that a link was copied, as this is useful for a parent to maintain
    relationships.
</p>

</body>
</html>
